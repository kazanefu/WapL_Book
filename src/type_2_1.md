# 基本的な型

コンパイラ版WapLは**静的型付き**言語であり、コンパイル時にすべての変数の型が判明している必要があります。基本的に型は変数や関数の宣言時に明示的に書く必要があり、それ以降は型推論が効きます。

**スカラー型**

スカラー型は、単独の値を表します。WapLにおいては主に4つのスカラー型があります: 整数、浮動小数点数、論理値、文字、です。

**整数型**

WapLでは2種類の整数型があります:`i32`と`i64`です。それぞれ32-bit、64-bitの符号ありの整数です。符号ありなので例えば`i32`だと$-(2^{31})$から$2^{31}-1$まで表現できます。

整数リテラルは小数点を含まないただの整数は`i64`になり、末尾に`s`をつけると`i32`になります。
|型|例|
|-|-|
|i64|-123|
|i32|42s|

**浮動小数点型**

整数型と同様に浮動小数点型にも32-bitと64-bitのものがあります:`f32`と`f64`です。

浮動小数点リテラルは小数点を持つ数値です。また、浮動小数点リテラルも整数リテラル同様に32-bitなら`s`を末尾につけ、つけなければ`f64`として扱われます。
|型|例|
|-|-|
|f64|-123.45|
|f32|42.0s|

**数値演算**

WapLにも全数値型に期待されうる標準的な数学演算が用意されています: 足し算、引き算、掛け算、割り算、余りです。WapLで特徴的なのは異なる型で数値演算を行った際には左側の型に合わせて自動でキャストされるということです。

```wapl
fn main():i32{
    // 足し算
    #=(sum, +(5,20.2), i64);// 25

    // 引き算
    #=(difference, -(10.5,3), f64);// 7.5

    // 掛け算
    #=(product, *(42,5), i64);// 210

    // 割り算
    #=(quotient, /(49.54,10.0), f64);// 4.954
    #=(floored, /(2,3), i64);// 0

    // 余り
    #=(remainder, %(43,5), i64);// 3

    return 0s;
}
```
これらの文の各式は、数学演算子を使用しており、一つの値に評価され、そして、変数に束縛されます。

**論理値型**

WapLの論理値型:`bool`は`true`と`false`の二つの値をとることができます。
```wapl
fn main():i32{
    #=(t, true, bool);
    #=(f, false, bool);
    return 0s;
}
```

**文字型**

WapLで文字は`char`型で扱います。`char`は8-bitであるためASCIIまでしか扱えません。また、文字リテラルはシングルクォーテーションで囲みます。
```wapl
fn main():i32{
    #=(c1, 'A', char);
    #=(c2, '\x41', char);
    #=(c3, '\u{41}',char);
    println(format("%c",c1));
    println(format("%c",c2));
    println(format("%c",c3));
    return 0s;
}
```
```bash
A
A
A
```
これらはすべて`A`を表します。

**ポインタ型**

WapLでは配列や文字列などもポインタ型であらわします。ポインタ型には4種類あり、`ptr:T` `*:T` `&:T` `&mut:T`があり、`T`のところにポインタが指す型が入ります。ポインタのポインタだったりする場合は`ptr:ptr:T`のようになります。それぞれのポインタ型の詳しい説明は[第3章 簡易的な所有権/借用](./ownerandborrow_3.md)でします。

```wapl
fn main():i32{
    #=(str, "hello", ptr:char);
    println(format("%s",str));

    #=(arr, salloc(i64,5), ptr:i64);
    =(arr, Array(3,1,4,1,5));
    #=(i,0,i64);
    loopif:(<(i,5)){
        println(format("%d", [](arr,i)));
        =(i,+(i,1));
    }

    #=(x, 10, i64);
    #=(p, &_(x), ptr:i64);
    println(format("%d", *_(p)));

    return 0s;
}
```
```bash
hello
3
1
4
1
5
10
```
このように、文字列や配列もポインタ型として扱います。文字列リテラルはダブルクォーテーションで囲みます。また、配列は先に型と要素数を指定して`salloc`でスタック上にメモリを確保して`Array`で値を列挙して配列に格納していき、`[](ポインタ変数, インデックス)`で値を取り出せます。`[]`では多次元配列でも`[](ポインタ変数, インデックス1, インデックス2, ...)`のようにして簡単に値を取り出すことができます。