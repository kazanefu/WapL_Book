# 変数

WapLコンパイラ版では変数の宣言時に型を明示的に記述する必要があり、宣言時にスタック上にメモリ確保をします。また、初期値の代入は宣言と同時に行う必要はありませんが、値を読み取るまでには代入をしてください
```wapl
fn main():i32{
    #=(x,10,i64);
    println(format("%d",x));
    =(x,5);
    println(format("%d",x));
    #=(y,_,i64);
    =(y,0);
    println(format("%d",y));
    return 0s;
}
```
実行すると以下のような出力が得られます。
```bash
10
5
0
```
このように変数の宣言は`#=(変数名,初期値,型)`の形式で行います。また、初期値なしで宣言する場合は`_`を初期値の入れます。また、代入は`=(変数,値)`という形式で記述します。
```wapl
fn main():i32{
    #=(x,_,i64);
    println(format("%d",x));// 代入されてないので0が出力される.
    return 0s;
}
```
このように値を代入せずに読み取るとエラーは出ませんが思わぬ値が渡される可能性があるので必ず読み取る前に値を代入するようにします。

宣言に伴う初期値は一部例外を除いて型が変数の型と一致する必要があります。以下のようなプログラムは`x`を`i64`の型で宣言しているにも関わらず、初期値が`'5'`と`char`型になっているためコンパイル時にエラーが出ます。
```wapl
fn main():i32{
    #=(x,'5',i64);
    return 0s;
}
```
```bash
Error: x Type miss match : expected Ident("i64") found Ident("char")
```

**シャドーイング**

内側のスコープで外側にあるのと同じ名前で新たに変数を宣言すると、前の変数は新しい変数に覆い隠され、そのスコープより内側では新しい変数の値が現れます。また、そのスコープを抜ければ再び前の変数の値が現れるようになります。
```wapl
fn main():i32{
    #=(x,5,i64);
    #=(x,+(x,5),i64);

    loopif:inner(true){
        #=(x,*(x,2),i64);
        println(format("The value of x in the inner scope is: %d",x));
        warpto(break-inner);
    }
    
    println(format("The value of x is: %d",x));
    
    return 0s;
}
```
```bash
The value of x in the inner scope is: 20
The value of x is: 10
```
このコードではまず`x`を`5`という値に束縛します。それから`#=(x,...`をもう一度行い、`x`をもとの値に`5`を足した値、つまり`10`で覆い隠します。次にスコープの中に入って`#=`で3回目の宣言でさらに元の値の2倍の`20`で覆い隠します。ここで、`x`を読み取るともちろん`20`です。スコープを抜けると3回目の宣言でのシャドーイングが終了するため`x`を読み取ると2回目の宣言による`10`が現れます。
