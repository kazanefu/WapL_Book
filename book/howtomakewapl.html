<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WapLコンパイラの作り方 - The WapL Programming Language 日本語版</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/wapl-38f40ac6.css">
        <link rel="stylesheet" href="theme/wapl-rainbow-f888ae4b.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b2448918.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-52f92f80.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The WapL Programming Language 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="waplコンパイラの作り方"><a class="header" href="#waplコンパイラの作り方">WapLコンパイラの作り方</a></h1>
<h2 id="環境"><a class="header" href="#環境">環境:</a></h2>
<ul>
<li>WSL2: Ubuntu24.04</li>
<li>Rust 1.91.1</li>
<li>Clang/LLVM 21.1.6</li>
<li>inkwell 0.7.1</li>
</ul>
<p><strong>Rustをインストール</strong></p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
</code></pre>
<p>バージョン確認</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<p><strong>LLVMのビルドとかで必要なものたちをインストール</strong></p>
<pre><code class="language-bash">sudo apt install -y build-essential cmake ninja-build git python3 libffi-dev
</code></pre>
<p><strong>LLVM 21.1.6 のソースコードをダウンロード</strong></p>
<pre><code class="language-bash">cd ~
git clone https://github.com/llvm/llvm-project.git --branch llvmorg-21.1.6 --depth=1
</code></pre>
<p><strong>LLVM をビルド</strong></p>
<pre><code class="language-bash">cd ~/llvm-project
mkdir build
cd build

cmake -G Ninja ../llvm \
    -DCMAKE_BUILD_TYPE=Release \
    -DLLVM_ENABLE_PROJECTS="clang;lld;polly" \
    -DLLVM_TARGETS_TO_BUILD="X86" \
    -DLLVM_ENABLE_RTTI=ON \
    -DLLVM_ENABLE_EH=ON \
    -DLLVM_ENABLE_TERMINFO=OFF \
    -DLLVM_ENABLE_Z3_SOLVER=OFF \
    -DLLVM_ENABLE_BINDINGS=OFF \
    -DLLVM_ENABLE_LIBXML2=OFF \
    -DLLVM_ENABLE_ZSTD=OFF \
    -DLLVM_ENABLE_ASSERTIONS=OFF \
    -DCMAKE_INSTALL_PREFIX=/usr/local/llvm-21
</code></pre>
<pre><code class="language-bash">ninja -j$(nproc)
</code></pre>
<p>ビルドには少し時間がかかります</p>
<p><strong>LLVMをインストール</strong></p>
<pre><code class="language-bash">sudo ninja install
</code></pre>
<p><strong>パスを通す</strong></p>
<pre><code class="language-bash">echo 'export PATH=/usr/local/llvm-21/bin:$PATH' &gt;&gt; ~/.bashrc
echo 'export LD_LIBRARY_PATH=/usr/local/llvm-21/lib:$LD_LIBRARY_PATH' &gt;&gt; ~/.bashrc
echo 'export LLVM_SYS_210_PREFIX=/usr/local/llvm-21' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<p>バージョン確認</p>
<pre><code>Clang --version
llvm-config --version
</code></pre>
<h2 id="waplコンパイラの大まかな設計"><a class="header" href="#waplコンパイラの大まかな設計">WapLコンパイラの大まかな設計</a></h2>
<pre><code>1.コードを書いたファイルを文字列として読み込む
↓
2.文字列からトークン列に変換する
↓
3.トークン列から抽象構文木(Abstruct Syntax Tree以後AST)を作る
↓
4.ASTから意味解析や超簡易的な所有権/借用のチェックと同時に中間言語としてLLVM IRを生成
↓
6.LLVM IRをClangに投げて最適化や実行ファイルの作成をしてもらう
</code></pre>
<p>一応2~4についてそれぞれ軽く説明します。</p>
<h3 id="2文字列からトークン列に変換する"><a class="header" href="#2文字列からトークン列に変換する">2.文字列からトークン列に変換する</a></h3>
<pre><code class="language-wapl">fn main():i32{
    println("Hello, world!");
    return 0s;
}
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0:Fn
1:Ident("main")
2:Lsep(LParen)
3:Rsep(RParen)
4:Colon
5:Ident("i32")
6:Lsep(LBrace)
7:Ident("println")
8:Lsep(LParen)
9:StringLiteral("Hello, world!")
10:Rsep(RParen)
11:Semicolon
12:Return
13:IntshortNumber(0)
14:Semicolon
15:Rsep(RBrace)
<span class="boring">}</span></code></pre>
<p>文字列からトークン列に変換する段階では上のように文字列を<strong>意味のある最小単位</strong>に分割していきます。
WapLではトークンは大きく<strong>識別子</strong>,<strong>定数値</strong>,<strong>予約語</strong>,<strong>区切り記号</strong>の4種類があり、一般的な言語にある<strong>演算子</strong>などはすべて識別子に統合されています。これはほとんどすべて関数呼び出しの記法と同じ記法で書くため演算子も関数名として扱ってしまうことができるからです。</p>
<p>WapLでのトークンの構成</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    //識別子
    Ident(String), //変数名や関数名
    //定数値
    IntNumber(i64), //整数値
    FloatNumber(f64), //浮動小数点数
    IntshortNumber(i32),// 32bit整数
    FloatshortNumber(f32),// 32bit 浮動小数点数
    StringLiteral(String), //ダブルクォーテーションで囲んだ文字列
    CharLiteral(char), //シングルクォーテーションで囲んだ文字
    BoolLiteral(bool), // true と false
    // キーワード
    ArrayCall, // Array(e1,e2,e3,...)のように配列を書くため他の関数呼び出しとの区別用
    Fn, //関数 fn
    Struct, //構造体 struct
    Point, //ラベル設置 point
    Warpto, //ジャンプ warpto
    WarptoIf, //条件付きジャンプ warptoif
    Return, //戻り値 return
    Import, //他ファイルを取り込む use
    LoopIf, //名前&amp;条件付き繰り返し loopif
    Declare, //関数の宣言のみ declare
    //記号や括弧
    Comma,// ","
    Semicolon, // ";"
    Colon, // ":"
    Lsep(LSeparator), //括弧の左側
    Rsep(RSeparator), //括弧の右側

    EOF, // 終わり
}
#[derive(Debug, Clone, PartialEq)]
pub enum LSeparator {
    LParen, // "("
    LBrace, // "{"
}
#[derive(Debug, Clone, PartialEq)]
pub enum RSeparator {
    RParen, // ")"
    RBrace, // "}"
}
<span class="boring">}</span></code></pre>
<h3 id="3トークン列からastを作る"><a class="header" href="#3トークン列からastを作る">3.トークン列からASTを作る</a></h3>
<p>2.で生成したトークン列は以下のように変換されます</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function(
    Function { 
        name: "main", 
        return_type: Ident("i32"), 
        args: [], 
        body: [
            Stmt { 
                expr: Call { 
                    name: "_TOPLEVEL_", 
                    args: [] 
                } 
            }, 
            Stmt { 
                expr: Call { 
                    name: "println", 
                    args: [
                        String("Hello, world!")
                    ] 
                } 
            }, 
            Stmt { 
                expr: Return([
                    IntSNumber(0)
                ]) 
            }
        ] 
    }
)
<span class="boring">}</span></code></pre>
<blockquote>
<p>注:WapLでは<code>main</code>関数の初めに<code>_TOPLEVEL_</code>を呼んで関数の外に書いた処理を先に行うため自動で<code>_TOPLEVEL_</code>が加えられている。</p>
</blockquote>
<p>このようにトークン列をASTにすることで上のように構造を持たせてトークンどうしの関係を表現することができます。WapLでのASTの構造は以下のように定義されています。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub enum Expr {
    IntNumber(i64),          //i64リテラル
    FloatNumber(f64),        //f64リテラル
    IntSNumber(i32),         //i32リテラル
    FloatSNumber(f32),       //f32リテラル
    String(String),          //文字列リテラル
    Char(char),              //charリテラル
    Bool(bool),              //boolリテラル
    ArrayLiteral(Vec&lt;Expr&gt;), //Array(e1,e2,e3,...)という形の配列リテラル
    Ident(String),           //変数名,型名,ワープに使うラベル名前などStringではない文字列
    Return(Vec&lt;Expr&gt;),       //関数の返り値
    Point(Vec&lt;Expr&gt;),        //ワープに使うラベル
    Call {
        name: String,
        args: Vec&lt;Expr&gt;,
    }, //関数呼び出し
    Warp {
        name: String,
        args: Vec&lt;Expr&gt;,
    }, //warpto,warptoif
    StructVal {
        _name: String,
        _args: Vec&lt;Expr&gt;,
    }, //structの実体
    TypeApply {
        base: String,
        args: Vec&lt;Expr&gt;,
    }, //ptr:typeとかのbase:type複雑な型
    Loopif {
        name: String,
        cond: Vec&lt;Expr&gt;,
        body: Vec&lt;Stmt&gt;,
    }, //loopif:name(cond){do}
}
#[derive(Debug, Clone)]
pub struct Stmt {
    pub expr: Expr,
}
#[derive(Debug, Clone)]
pub enum TopLevel {
    Function(Function),
    Struct(Struct),
    Declare(Declare),
}
#[derive(Debug, Clone)]
pub struct Declare {
    pub name: String,
    pub return_type: Expr,
    pub args: Vec&lt;Expr&gt;,
    pub is_vararg: bool,
}
#[derive(Debug, Clone)]
pub struct Function {
    pub name: String,
    pub return_type: Expr,
    pub args: Vec&lt;(Expr, Expr)&gt;, //(type,name)
    pub body: Vec&lt;Stmt&gt;,
}
#[derive(Debug, Clone)]
pub struct Struct {
    pub name: String,
    pub _return_type: Expr,
    pub args: Vec&lt;(Expr, Expr)&gt;, //(type,name)
}

#[derive(Debug, Clone)]
pub struct Program {
    pub functions: Vec&lt;TopLevel&gt;, //functions &amp; structs &amp; toplevel call
    pub has_main: bool,
}
<span class="boring">}</span></code></pre>
<h3 id="4中間言語llvm-irを生成"><a class="header" href="#4中間言語llvm-irを生成">4.中間言語LLVM IRを生成</a></h3>
<pre><code class="language-llvm">; ModuleID = 'wapl_module'
source_filename = "wapl_module"

@str_0 = private unnamed_addr constant [14 x i8] c"Hello, world!\00", align 1
@println_fmt_1 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1

declare i64 @strtol(ptr, ptr, i32)

declare double @atof(ptr)

declare i32 @printf(ptr, ...)

declare i32 @sprintf(ptr, ptr, ...)

declare ptr @realloc(ptr, i64)

declare ptr @malloc(i64)

declare void @free(ptr)

declare i32 @scanf(ptr, ...)

define i32 @_TOPLEVEL_() {
entry:
  ret i32 0
}

define i32 @main() {
entry:
  %ret_val = alloca i32, align 4
  %calltmp = call i32 @_TOPLEVEL_()
  %printf = call i32 (ptr, ...) @printf(ptr @println_fmt_1, ptr @str_0)
  ret i32 0
}
</code></pre>
<p>この段階では3.で生成したASTから意味を読み取り,それに合わせてLLVM IRを生成します。WapLではデフォルトでラッパーを用意しているCの関数の宣言をや文字列リテラル、<code>_TOPLEVEL_</code>関数などが最初に作られて、その後、実際にWapLで書いたプログラムが書かれます。<code>main</code>では、<code>entry</code>ブロックを設置、戻り値のためのメモリを一応確保(初期は<code>return</code>を書かないでもいいようにする設計だった名残で今はほとんど死んでる)、<code>_TOPLEVEL_</code>を呼ぶ、<code>println</code>はC言語の<code>printf</code>のラッパーなので<code>printf</code>を呼ぶ、<code>0</code>を返すということが書かれています。</p>
<h2 id="トークン列の生成"><a class="header" href="#トークン列の生成">トークン列の生成</a></h2>
<p>では具体的にどのようにトークン列を生成しているのか見てみましょう。
まずトークンを作る構造体を以下のように定義します。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Tokenizer {
    chars: Vec&lt;char&gt;,
    pos: usize,
}

impl Tokenizer{
    pub fn new(input: &amp;str) -&gt; Self {
        Self {
            chars: input.chars().collect(),
            pos: 0,
        }
    }
    fn peek(&amp;self) -&gt; Option&lt;char&gt; {
        self.chars.get(self.pos).cloned()
    }

    fn next_char(&amp;mut self) -&gt; Option&lt;char&gt; {
        let ch = self.peek()?;
        self.pos += 1;
        Some(ch)
    }

    fn match_next(&amp;mut self, expected: char) -&gt; bool {
        if self.peek() == Some(expected) {
            self.pos += 1;
            true
        } else {
            false
        }
    }
}
<span class="boring">}</span></code></pre>
<p><code>new</code>で初期化、<code>peek</code>で今いる場所の文字を読み取り、<code>next_char</code>で今いる場所の文字を読み取って文字を一つ進める、<code>match_next</code>で今いる場所の文字が期待するものと一致すれば進める。というように基本的な動きを定義します。</p>
<p>次に、<code>impl Tokenizer</code>に空白とコメントを飛ばすメソッドを追加します。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn skip_whitespace(&amp;mut self) {
    while let Some(c) = self.peek() {
        if c.is_whitespace() {
            self.pos += 1;
        } else {
            self.skip_comment();
            break;
        }
    }
}
fn skip_comment(&amp;mut self) {
    loop {
        if self.peek() != Some('/') || self.chars.get(self.pos + 1) != Some(&amp;'/') {
            return;
        }

        self.pos += 2;

        while let Some(c) = self.peek() {
            self.pos += 1;
            if c == '\n' {
                break;
            }
        }

        self.skip_whitespace();
    }
}
<span class="boring">}</span></code></pre>
<p><code>skip_whitespace</code>では文字が空白である限り進め、空白ではなくなったときにコメントがあればそれもスキップするようにしています。<code>skip_comment</code>では<code>//</code>を見つけてその分の2文字進めて改行が来るまで進め続けて改行が来たら空白をスキップしてまたコメントが来ないか確認するということを繰り返して、コメントじゃないのが来たら終わります。</p>
<p>次に、文字列や文字のリテラルをトークンにするメソッドを<code>impl Tokenizer</code>に追加します。ファイルや標準入力などから受け取った文字列は<code>"\n"</code>が<code>"\\n"</code>になってたりなどするのでそれを書いた通りの形に戻したり、<code>\x61</code>や<code>\u{A66E}</code>のように文字コードでの入力をできるようにします。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn string_and_char_tokenize(&amp;mut self) -&gt; String {
    let mut s = String::new();
    while let Some(c) = self.next_char() {
        if c == '"' || c == '\'' {
            break;
        }
        if c != '\\' {
            s.push(c);
            continue;
        }

        if self.match_next('n') {
            s.push('\n');
        } else if self.match_next('0') {
            s.push('\0');
        } else if self.match_next('\\') {
            s.push('\\');
        } else if self.match_next('r') {
            s.push('\r');
        } else if self.match_next('t') {
            s.push('\t');
        } else if self.match_next('"') {
            s.push('"');
        } else if self.match_next('x') {
            let h1 = self.next_char().unwrap();
            let h2 = self.next_char().unwrap();
            let byte = u8::from_str_radix(&amp;format!("{}{}", h1, h2), 16).unwrap();
            s.push(byte as char);
        } else if self.match_next('u') {
            if self.match_next('{') {
                let mut hex = String::new();

                while let Some(cc) = self.next_char() {
                    if cc == '}' {
                        break;
                    }
                    hex.push(cc);
                }
                let cp = u32::from_str_radix(&amp;hex, 16).unwrap();
                let cch = char::from_u32(cp).unwrap();
                s.push(cch);
            } else {
                s.push('\\');
                s.push('u');
            }
        } else {
            s.push(c);
        }
    }
    s
}
<span class="boring">}</span></code></pre>
<p>見ての通り<code>'\\'</code>が来たらその場所を置き換えるようにしています。</p>
<p>最後にこれらのメソッドを使ってトークンを作ってトークン列に追加していくメソッドを追加します。まず空白とコメントをスキップして、次に文字があるかを確かめ、その後、文字列リテラルか-&gt;文字リテラルか-&gt;数値リテラルか(もしそうだとしたら整数か浮動小数点数かまた何ビットか)-&gt;識別子やキーワード-&gt;括弧や記号、といった順で確かめていきトークン列に追加するということをしています。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn next_token(&amp;mut self) -&gt; Token {
    loop {
        self.skip_whitespace();
        self.skip_comment();
        break;
    }

    let ch = match self.next_char() {
        Some(c) =&gt; c,
        None =&gt; return Token::EOF,
    };

    // ----- String -----
    if ch == '"' {
        return Token::StringLiteral(self.string_and_char_tokenize());
    }
    //----char-----
    if ch == '\'' {
        let c = self.string_and_char_tokenize().chars().collect::&lt;Vec&lt;_&gt;&gt;()[0];
        return Token::CharLiteral(c);
    }

    // ----- Number -----
    if ch.is_ascii_digit() || ch == '-' {
        let mut s = ch.to_string();
        let mut is_float = false;
        let mut is_short = false;
        while let Some(c) = self.peek() {
            if c.is_ascii_digit() || c == '.' ||c=='s'{
                if c == '.' {
                    is_float = true;
                }
                if c == 's'{
                    is_short = true;
                    self.pos += 1;
                    break;
                }
                s.push(c);
                self.pos += 1;
            } else {
                break;
            }
        }
        if s != "-" {
            if is_float {
                return if !is_short{Token::FloatNumber(s.parse::&lt;f64&gt;().unwrap())}else{Token::FloatshortNumber(s.parse::&lt;f32&gt;().unwrap())};
            } else {
                return if !is_short{Token::IntNumber(s.parse::&lt;i64&gt;().unwrap())}else{Token::IntshortNumber(s.parse::&lt;i32&gt;().unwrap())};
            }
        }
    }

    // ----- Identifier / Keyword -----
    if !ch.is_ascii_digit()
        &amp;&amp; ch != ','
        &amp;&amp; ch != ';'
        &amp;&amp; ch != '{'
        &amp;&amp; ch != '}'
        &amp;&amp; ch != '('
        &amp;&amp; ch != ')'
        &amp;&amp; ch != ':'
    {
        let mut s = ch.to_string();
        while let Some(c) = self.peek() {
            if c != ','
                &amp;&amp; c != ';'
                &amp;&amp; c != '{'
                &amp;&amp; c != '}'
                &amp;&amp; c != '('
                &amp;&amp; c != ')'
                &amp;&amp; c != ' '
                &amp;&amp; c != ':'
                &amp;&amp; c != '\n'
            {
                s.push(c);
                self.pos += 1;
            } else {
                break;
            }
        }

        return match s.as_str() {
            "fn" =&gt; Token::Fn,
            "struct" =&gt; Token::Struct,
            "point" =&gt; Token::Point,
            "warpto" =&gt; Token::Warpto,
            "warptoif" =&gt; Token::WarptoIf,
            "true" =&gt; Token::BoolLiteral(true),
            "false" =&gt; Token::BoolLiteral(false),
            "return" =&gt; Token::Return,
            "Array" =&gt; Token::ArrayCall,
            "import" | "use" =&gt; Token::Import,
            "loopif" =&gt; Token::LoopIf,
            "declare" =&gt; Token::Declare,
            _ =&gt; Token::Ident(s),
        };
    }

    // ----- Operators / Signs -----
    match ch {
        ',' =&gt; Token::Comma,
        ';' =&gt; Token::Semicolon,
        ':' =&gt; Token::Colon,
        '(' =&gt; Token::Lsep(LSeparator::LParen),
        ')' =&gt; Token::Rsep(RSeparator::RParen),
        '{' =&gt; Token::Lsep(LSeparator::LBrace),
        '}' =&gt; Token::Rsep(RSeparator::RBrace),
        _ =&gt; Token::EOF,
    }
}

pub fn tokenize(&amp;mut self) -&gt; Vec&lt;Token&gt; {
    let mut tokens = Vec::new();

    loop {
        let t = self.next_token();
        if t == Token::EOF {
            break;
        }
        tokens.push(t);
    }

    tokens
}
<span class="boring">}</span></code></pre>
<h2 id="astの生成"><a class="header" href="#astの生成">ASTの生成</a></h2>
<p>まずは、ASTを作る構造体を以下のように定義します。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Parser {
    tokens: Vec&lt;Token&gt;,
    pos: usize,
    has_main: bool,
}
impl Parser{
    pub fn new(tokens: Vec&lt;Token&gt;) -&gt; Self {
        Self {
            tokens,
            pos: 0,
            has_main: false,
        }
    }

    fn peek(&amp;self) -&gt; Option&lt;&amp;Token&gt; {
        self.tokens.get(self.pos)
    }
    fn peek_back(&amp;self) -&gt; Option&lt;&amp;Token&gt; {
        self.tokens.get(self.pos - 1)
    }
    fn _peek_front(&amp;self) -&gt; Option&lt;&amp;Token&gt; {
        self.tokens.get(self.pos + 1)
    }
    fn no_return_next(&amp;mut self) {
        self.pos += 1;
    }
    fn no_return_back(&amp;mut self) {
        self.pos -= 1;
    }
    fn next(&amp;mut self) -&gt; Option&lt;&amp;Token&gt; {
        let t = self.tokens.get(self.pos);
        self.pos += 1;
        t
    }

    fn expect(&amp;mut self, expected: &amp;Token) {
        let t = self.next().expect("unexpected EOF");
        if t != expected {
            panic!("expected {:?}, got {:?}", expected, t);
        }
    }
    fn check(&amp;self, expected: &amp;Token) -&gt; bool {
        let t = self.peek().expect("unexpected EOF");
        t == expected
    }

    fn consume_comma(&amp;mut self) {
        match self.peek() {
            Some(Token::Comma) =&gt; {
                self.next();
            }
            _ =&gt; {}
        }
    }
    fn consume_semicolon(&amp;mut self) {
        match self.peek() {
            Some(Token::Semicolon) =&gt; {
                self.next();
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Tokenizerと同様に<code>new</code>で初期化、<code>peek</code>で今いるとこのトークンを読み取る、<code>peek_back</code>で一つ前を読み取る、<code>_peek_front</code>は使ってないが一つ先を読み取るもの、<code>no_return_back</code>と<code>no_return_next</code>は戻り値なしで次に進めたり一つ戻したりする、<code>next</code>で今のを読み取って次に進める、<code>expect</code>は期待するトークンと異なればエラーを出す、<code>check</code>は期待するトークンと一致するかのboolを返す、<code>consume_XXX</code>はXXXを飛ばす。という基本的な動作を定義する。</p>
<p>次に<code>use</code>で他のファイルもトークン列を作る-&gt;ASTを再帰的に作っていくためのメソッドを追加する。ここではすでにASTを作ったファイルを重複して<code>use</code>で呼びだしてしまわないようにASTを作ったらファイル名を記録していき、その記録にまだ登録されてないことを確認してからASTをつくっている。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn connect_use(&amp;mut self, import_map: &amp;mut Vec&lt;String&gt;, funcs: &amp;mut Vec&lt;TopLevel&gt;) {
    self.no_return_next();
    let Token::StringLiteral(path) = self.next().unwrap_or(&amp;Token::EOF) else {
        return;
    };
    let source = fs::read_to_string(path).expect("ファイルを読み込めませんでした");
    if import_map.contains(&amp;path) {
        return;
    }
    let mut tokenizer = Tokenizer::new(source.as_str());
    let tokens = tokenizer.tokenize();
    let mut parser = Parser::new(tokens);
    let parsed = parser.parse_program(import_map);
    for module_ast in parsed.functions {
        funcs.push(module_ast);
    }
    import_map.push(path.to_string());
}
<span class="boring">}</span></code></pre>
<p>ではここからパースしてASTを作るところを見てみよう。プログラム全体のパースを駆動するのは以下のメソッドを使う。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_program(&amp;mut self, import_map: &amp;mut Vec&lt;String&gt;) -&gt; Program {
    let mut funcs = Vec::new();

    while let Some(tok) = self.peek() {
        match tok {
            Token::Import =&gt; {
                self.connect_use(import_map, &amp;mut funcs);
            }
            Token::Fn =&gt; {
                funcs.push(TopLevel::Function(self.parse_function()));
            }
            Token::Struct =&gt; {
                funcs.push(TopLevel::Struct(self.parse_struct()));
            }
            Token::Declare =&gt; {
                funcs.push(TopLevel::Declare(self.parse_declare()));
            }
            Token::Semicolon =&gt; {
                self.no_return_next();
            }
            _ =&gt; {
                // toplevel eval
                let expr = self.parse_expr();
                match expr {
                    Expr::Call { name, args: _ } if name == "main" =&gt; {}
                    other =&gt; {
                        funcs.push(TopLevel::Function(Function {
                            name: "toplevel_child".to_string(),
                            return_type: Expr::Ident("void".to_string()),
                            args: vec![],
                            body: vec![Stmt { expr:other }],
                        }));
                    }
                }
            }
        }
    }

    Program {
        functions: funcs,
        has_main: self.has_main,
    }
}
<span class="boring">}</span></code></pre>
<p>また、それぞれの文と式を以下のようなメソッドたちを使ってパースする。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// -------------------------
// Parse function
// fn name():i32 { ... }
// -------------------------
fn parse_function(&amp;mut self) -&gt; Function {
    self.expect(&amp;Token::Fn);

    let mut is_main = false;
    // function name
    let mut name = match self.next() {
        Some(Token::Ident(s)) =&gt; s.clone(),
        other =&gt; panic!("expected function name, got {:?}", other),
    };
    name = if name == "main" {
        is_main = true;
        self.has_main = true;
        "main".to_string()
    } else {
        name
    };

    // (type name,type name,...)
    self.expect(&amp;Token::Lsep(LSeparator::LParen));
    let mut args = Vec::new();
    while let Some(token_arg_type) = self.peek() {
        if *token_arg_type == Token::Rsep(RSeparator::RParen) {
            break;
        }
        self.no_return_next();
        let arg_type = match self.peek_back() {
            Some(Token::Ident(s)) =&gt; self.parse_type_apply(s.clone()),
            other =&gt; panic!("expected arg type, got {:?}", other),
        };
        let arg_name = match self.next() {
            Some(Token::Ident(s)) =&gt; Expr::Ident(s.clone()),
            other =&gt; panic!("expected arg name, got {:?}", other),
        };
        args.push((arg_type, arg_name));
        self.consume_comma();
    }
    self.expect(&amp;Token::Rsep(RSeparator::RParen));
    let mut return_type = Expr::Ident("void".to_string());
    if self.check(&amp;Token::Colon) {
        self.expect(&amp;Token::Colon);
        if !self.check(&amp;Token::Lsep(LSeparator::LBrace)) {
            return_type = self.parse_return_type();
        }
    }
    // { statements }
    self.expect(&amp;Token::Lsep(LSeparator::LBrace));
    self.consume_semicolon();

    let mut stmts = Vec::new();
    if is_main {
        stmts.push(Stmt {
            expr: Expr::Call {
                name: "_TOPLEVEL_".to_string(),
                args: vec![],
            },
        })
    }

    while let Some(tok) = self.peek() {
        if *tok == Token::Rsep(RSeparator::RBrace) {
            break;
        }
        // optional ;
        if let Some(Token::Semicolon) = self.peek() {
            self.next();
        }

        let expr = self.parse_expr();
        stmts.push(Stmt { expr });

        // optional ;
        if let Some(Token::Semicolon) = self.peek() {
            self.next();
        }
    }

    self.expect(&amp;Token::Rsep(RSeparator::RBrace));
    self.consume_semicolon();

    Function {
        name,
        return_type,
        args: args,
        body: stmts,
    }
}
// -------------------------
// Parse struct
// struct name{ i32 a, ptr b,..., }
//
fn parse_struct(&amp;mut self) -&gt; Struct {
    self.expect(&amp;Token::Struct);

    // struct name
    let (name, return_type) = match self.next() {
        Some(Token::Ident(s)) =&gt; (s.clone(), Expr::Ident(s.clone())),
        other =&gt; panic!("expected struct name, got {:?}", other),
    };
    self.expect(&amp;Token::Lsep(LSeparator::LBrace));
    self.consume_semicolon();
    let mut args = Vec::new();
    while let Some(token_arg_type) = self.peek() {
        if *token_arg_type == Token::Rsep(RSeparator::RBrace) {
            break;
        }
        self.no_return_next();
        let arg_type = match self.peek_back() {
            Some(Token::Ident(s)) =&gt; self.parse_type_apply(s.clone()), //Expr::Ident(s.clone()),
            other =&gt; panic!("expected arg type, got {:?}", other),
        };
        let arg_name = match self.next() {
            Some(Token::Ident(s)) =&gt; Expr::Ident(s.clone()),
            other =&gt; panic!("expected arg name, got {:?}", other),
        };
        args.push((arg_type, arg_name));
        self.consume_comma();
    }
    self.expect(&amp;Token::Rsep(RSeparator::RBrace));
    Struct {
        name,
        _return_type: return_type,
        args,
    }
}

fn parse_declare(&amp;mut self) -&gt; Declare {
    self.expect(&amp;Token::Declare);

    // function name
    let mut name = match self.next() {
        Some(Token::Ident(s)) =&gt; s.clone(),
        other =&gt; panic!("expected function name, got {:?}", other),
    };
    name = if name == "main" {
        "main".to_string()
    } else {
        name
    };

    // (type name,type name,...)
    self.expect(&amp;Token::Lsep(LSeparator::LParen));
    let mut args = Vec::new();
    let mut is_vararg = false;
    while let Some(token_arg_type) = self.peek() {
        if *token_arg_type == Token::Rsep(RSeparator::RParen) {
            break;
        }
        self.no_return_next();
        let arg_type = match self.peek_back() {
            Some(Token::Ident(s)) =&gt; self.parse_type_apply(s.clone()),
            other =&gt; panic!("expected arg type, got {:?}", other),
        };
        match arg_type {
            Expr::Ident(s) if s == "..." =&gt; {
                is_vararg = true;
            }
            _ =&gt; {
                args.push(arg_type);
            }
        }
        self.consume_comma();
    }
    self.expect(&amp;Token::Rsep(RSeparator::RParen));
    let mut return_type = Expr::Ident("void".to_string());
    if self.check(&amp;Token::Colon) {
        self.expect(&amp;Token::Colon);
        if !self.check(&amp;Token::Lsep(LSeparator::LBrace)) {
            return_type = self.parse_return_type();
        }
    }
    self.consume_semicolon();

    self.consume_semicolon();

    Declare {
        name,
        return_type,
        args: args,
        is_vararg,
    }
}
// -------------------------
// Parse expression (function-call style)
//
//   +(1,2)
//   =(a, 1, i32)
//   println(a)
//   warpto(label)
//   loopif:name(cond){}
// -------------------------
fn parse_return_type(&amp;mut self) -&gt; Expr {
    self.no_return_next();
    let token = self.peek_back();
    match token {
        Some(Token::Ident(name)) =&gt; {
            let front = self.peek();
            match front {
                Some(Token::Colon) =&gt; self.parse_type_apply(name.clone()),
                Some(_) =&gt; Expr::Ident(name.clone()),
                _ =&gt; panic!("unexpected EOF in expression"),
            }
        }
        Some(tok) =&gt; panic!(
            "{}expression begins with unexpected token {:?}",
            self.pos, tok
        ),
        None =&gt; panic!("unexpected EOF in expression"),
    }
}
fn parse_expr(&amp;mut self) -&gt; Expr {
    self.no_return_next();
    let token = self.peek_back();
    match token {
        Some(Token::IntNumber(n)) =&gt; Expr::IntNumber(*n),
        Some(Token::FloatNumber(n)) =&gt; Expr::FloatNumber(*n),
        Some(Token::IntshortNumber(n)) =&gt; Expr::IntSNumber(*n),
        Some(Token::FloatshortNumber(n)) =&gt; Expr::FloatSNumber(*n),
        Some(Token::StringLiteral(s)) =&gt; Expr::String(s.clone()),
        Some(Token::CharLiteral(c)) =&gt; Expr::Char(*c),
        Some(Token::BoolLiteral(b)) =&gt; Expr::Bool(*b),
        Some(Token::Return) =&gt; Expr::Return(vec![self.parse_expr()]),
        Some(Token::Point) =&gt; Expr::Point(vec![self.parse_expr()]),
        Some(Token::Warpto) =&gt; self.parse_call("warpto".to_string()),
        Some(Token::WarptoIf) =&gt; self.parse_call("warptoif".to_string()),
        Some(Token::LoopIf) =&gt; self.parse_loopif(),
        Some(Token::ArrayCall) =&gt; self.parse_call("Array".to_string()),
        Some(Token::Ident(name)) =&gt; self.parse_ident_expr(name.clone()),
        Some(tok) =&gt; panic!(
            "{}expression begins with unexpected token {:?}",
            self.pos, tok
        ),
        None =&gt; panic!("unexpected EOF in expression"),
    }
}
fn parse_ident_expr(&amp;mut self, name: String) -&gt; Expr {
    let front = self.peek();
    match front {
        Some(Token::Lsep(LSeparator::LParen)) =&gt; self.parse_call(name.clone()),
        Some(Token::Lsep(LSeparator::LBrace)) =&gt; self.parse_structval(name.clone()),
        Some(Token::Colon) =&gt; self.parse_type_apply(name.clone()),
        Some(_) =&gt; Expr::Ident(name.clone()),
        _ =&gt; panic!("unexpected EOF in expression"),
    }
}

// -------------------------
// Function call parsing
//
// name(arg1, arg2, ...)
// -------------------------
fn parse_type_apply(&amp;mut self, name: String) -&gt; Expr {
    match self.next() {
        Some(Token::Colon) =&gt; {}
        _ =&gt; {
            self.no_return_back();
            return Expr::Ident(name.clone());
        } //normal types
    }
    let mut args = Vec::new();
    match self.peek() {
        _ =&gt; {
            let arg = self.parse_return_type();
            args.push(arg);
            self.consume_comma();
        }
    }
    Expr::TypeApply { base: name, args }
}
fn parse_structval(&amp;mut self, name: String) -&gt; Expr {
    match self.next() {
        Some(Token::Lsep(LSeparator::LBrace)) =&gt; {}
        other =&gt; panic!(
            "expected '{{' after function name {:?}, got {:?}",
            name, other
        ),
    }
    let mut args = Vec::new();

    loop {
        match self.peek() {
            Some(Token::Rsep(RSeparator::RBrace)) =&gt; {
                self.next();
                break;
            }
            _ =&gt; {
                let arg = self.parse_expr();
                args.push(arg);
                self.consume_comma();
            }
        }
    }
    Expr::StructVal {
        _name: name,
        _args: args,
    }
}
fn parse_call(&amp;mut self, mut name: String) -&gt; Expr {
    match self.next() {
        Some(Token::Lsep(LSeparator::LParen)) =&gt; {}
        other =&gt; panic!(
            "expected '(' after function name {:?}, got {:?}",
            name, other
        ),
    }

    let mut args = Vec::new();

    loop {
        match self.peek() {
            Some(Token::Rsep(RSeparator::RParen)) =&gt; {
                self.next();
                break;
            }
            _ =&gt; {
                let arg = self.parse_expr();
                args.push(arg);
                self.consume_comma();
            }
        }
    }
    if name == "warpto" || name == "warptoif" {
        self.consume_semicolon();
        return Expr::Warp { name, args };
    } else if name == "Array" {
        self.consume_semicolon();
        return Expr::ArrayLiteral(args);
    }
    name = if name == "main" {
        "main".to_string()
    } else {
        name
    };
    self.consume_semicolon();
    Expr::Call { name, args }
}
fn parse_loopif(&amp;mut self) -&gt; Expr {
    self.expect(&amp;Token::Colon);

    // loopif name
    let name = match self.next() {
        Some(Token::Ident(s)) =&gt; s.clone(),
        _ =&gt; {
            self.no_return_back();
            "loop".to_string()
        }
    };

    // (cond)
    match self.next() {
        Some(Token::Lsep(LSeparator::LParen)) =&gt; {}
        other =&gt; panic!("expected '(' after loopif name {:?}, got {:?}", name, other),
    }

    let mut args = Vec::new();

    loop {
        match self.peek() {
            Some(Token::Rsep(RSeparator::RParen)) =&gt; {
                self.next();
                break;
            }
            _ =&gt; {
                let arg = self.parse_expr();
                args.push(arg);
                self.consume_comma();
            }
        }
    }

    // { statements }
    self.expect(&amp;Token::Lsep(LSeparator::LBrace));
    self.consume_semicolon();

    let mut stmts = Vec::new();

    while let Some(tok) = self.peek() {
        if *tok == Token::Rsep(RSeparator::RBrace) {
            break;
        }
        // optional ;
        if let Some(Token::Semicolon) = self.peek() {
            self.next();
        }

        let expr = self.parse_expr();
        stmts.push(Stmt { expr });

        // optional ;
        if let Some(Token::Semicolon) = self.peek() {
            self.next();
        }
    }

    self.expect(&amp;Token::Rsep(RSeparator::RBrace));
    self.consume_semicolon();

    Expr::Loopif {
        name,
        cond: args,
        body: stmts,
    }
}
<span class="boring">}</span></code></pre>
<p>見ての通りWapLコンパイラのパーサは再帰下降パーサになっている。</p>
<blockquote>
<p>再帰下降構文解析（さいきかこうこうぶんかいせき、英語: Recursive Descent Parsing）は、相互再帰型の手続き（あるいは再帰的でない同等の手続き）で構成されるLL法のトップダウン構文解析であり、各プロシージャが文法の各生成規則を実装することが多い。従って、生成されるプログラムの構造はほぼ正確にその文法を反映したものとなる。そのような実装の構文解析器を再帰下降パーサ（Recursive Descent Parser）と呼ぶ。　<a href="https://ja.wikipedia.org/wiki/%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">wikiより</a></p>
</blockquote>
<h2 id="llvm-irの生成"><a class="header" href="#llvm-irの生成">LLVM IRの生成</a></h2>
<p>以下のような構造体を作る。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Codegen&lt;'ctx&gt; {
    pub context: &amp;'ctx Context,
    pub module: Module&lt;'ctx&gt;,
    pub builder: Builder&lt;'ctx&gt;,
    pub struct_types: HashMap&lt;String, StructType&lt;'ctx&gt;&gt;,// structの型を名前をキーにして記録
    pub struct_fields: HashMap&lt;String, Vec&lt;(String, BasicTypeEnum&lt;'ctx&gt;, u32, Expr)&gt;&gt;, // structのフィールドの名前とインデックスと型をstructの名前をキーにして記録
    str_counter: usize, // グローバルに確保した文字列の数
    current_fn: Option&lt;FunctionContext&lt;'ctx&gt;&gt;, // 現在コンパイルしている関数とその関数内のpointで作ったラベルやwarptoなどの元ブロック
    pub function_types: HashMap&lt;String, Expr&gt;, // 関数の戻り値の型
    pub current_owners: HashMap&lt;String, bool&gt;, // 現在の関数全体での所有権を持っているポインタが有効かどうかを記録
    pub scope_owners: ScopeOwner, // 現在のスコープで所有権を持ってるポインタが有効かどうかを記録し,リターン時にこれに基づいてメモリリークを検出
}
struct PendingJump&lt;'ctx&gt; {
    from: BasicBlock&lt;'ctx&gt;,
}
#[derive(Clone)]
struct VariablesPointerAndTypes&lt;'ctx&gt; {
    ptr: PointerValue&lt;'ctx&gt;,
    typeexpr: Expr,
}
struct FunctionContext&lt;'ctx&gt; {
    function: FunctionValue&lt;'ctx&gt;,
    labels: HashMap&lt;String, BasicBlock&lt;'ctx&gt;&gt;, //labels(already exist)
    unresolved: HashMap&lt;String, Vec&lt;PendingJump&lt;'ctx&gt;&gt;&gt;, //labels(unresolved)
}
#[derive(Clone)]
pub struct ScopeOwner {
    pos: usize,
    owners: Vec&lt;HashMap&lt;String, bool&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<p>全体のコンパイルを駆動はメソッドがしています</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compile_program(&amp;mut self, program: Program) {
    if program.has_main {
        self.compile_declare(Declare {
            name: "_TOPLEVEL_".to_string(),
            return_type: Expr::Ident("i32".to_string()),
            args: vec![],
            is_vararg: false,
        });
    }

    for func in program.functions {
        match func {
            TopLevel::Function(f) =&gt; {
                self.compile_function(f);
            }
            TopLevel::Struct(s) =&gt; {
                self.compile_struct(s);
            }
            TopLevel::Declare(d) =&gt; {
                self.compile_declare(d);
            }
        }
    }
    combine_toplevel(&amp;self.module, &amp;self.builder, program.has_main);
}
<span class="boring">}</span></code></pre>
<p>まず最初に<code>_TOPLEVEL_</code>の宣言をしてその後,関数か構造体か関数の宣言かのコンパイルを順に呼び出していきます。そして最後にトップレベルにある式を<code>_TOPLEVEL_</code>にまとめています。</p>
<p>では次は関数のIRを作るところを見てみましょう</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compile_function(&amp;mut self, func: Function) {
    if self.function_types.contains_key(&amp;func.name) {
        panic!("function '{}' already defined", func.name);
    }
    // --- type of return value ---
    let return_type_is_void = matches!(func.return_type, Expr::Ident(ref s) if s == "void");

    let return_type_enum = if return_type_is_void {
        None
    } else {
        Some(self.llvm_type_from_expr(&amp;func.return_type))
    };

    // --- type of arguments ---
    let arg_types: Vec&lt;BasicTypeEnum&gt; = func
        .args
        .iter()
        .map(|(ty, _)| self.llvm_type_from_expr(ty))
        .collect();

    // ---convert to Metadata type ---
    let arg_types_meta: Vec&lt;BasicMetadataTypeEnum&gt; =
        arg_types.iter().map(|t| (*t).into()).collect();

    // --- LLVM gen function ---
    let fn_type = if return_type_is_void {
        self.context.void_type().fn_type(&amp;arg_types_meta, false)
    } else {
        return_type_enum.unwrap().fn_type(&amp;arg_types_meta, false)
    };

    // --- add function ---
    let llvm_func = self.module.add_function(&amp;func.name, fn_type, None);
    self.function_types
        .insert(func.name.clone(), func.return_type);
    let entry = self.context.append_basic_block(llvm_func, "entry");
    self.builder.position_at_end(entry);

    // --- alloca &amp; initialize args ---
    self.current_owners = HashMap::new();
    self.scope_owners = ScopeOwner::new();
    let mut variables: HashMap&lt;String, VariablesPointerAndTypes&lt;'ctx&gt;&gt; = HashMap::new();
    for (i, (ty, arg_expr)) in func.args.iter().enumerate() {
        let param = llvm_func.get_nth_param(i as u32).unwrap();

        // get arg names (Expr::Ident(name))
        let arg_name = match arg_expr {
            Expr::Ident(name) =&gt; name.as_str(),
            _ =&gt; panic!("Function argument name must be identifier"),
        };
        param.set_name(arg_name);

        // alloca anyway
        let alloca = self
            .builder
            .build_alloca(param.get_type(), arg_name)
            .expect("alloca failed");
        self.builder.build_store(alloca, param).unwrap();
        variables.insert(
            arg_name.to_string(),
            VariablesPointerAndTypes {
                ptr: alloca,
                typeexpr: ty.clone(),
            },
        );
        match ty {
            Expr::TypeApply { base, args: _args } if base == "*" =&gt; {
                self.current_owners.insert(arg_name.to_string(), true);
                self.scope_owners.set_true(arg_name.to_string());
            }
            _ =&gt; {}
        }
    }
    //alloca return value
    let _ret_alloca = if !return_type_is_void {
        Some(
            self.builder
                .build_alloca(return_type_enum.unwrap(), "ret_val"),
        )
    } else {
        None
    };

    self.current_fn = Some(FunctionContext {
        function: llvm_func,
        labels: HashMap::new(),
        unresolved: HashMap::new(),
    });

    // --- function body ---
    for stmt in func.body {
        let _value = self.compile_stmt(&amp;stmt, &amp;mut variables);
    }

    // --- temporary return ---
    if return_type_is_void {
        self.builder.build_return(None).unwrap();
    } else {
        // // 仮に i32 を戻り値として返す
        // let zero = self.context.i32_type().const_int(0, false);
        // self.builder.build_return(Some(&amp;zero)).unwrap();
    }
    //Exit from the current function
    self.current_fn = None;
}
<span class="boring">}</span></code></pre>
<p>まず、関数がすでに定義されていないかの確認をします。次にASTの戻り値の型をLLVM IRの型に変換します。また、同様にして引数の型もIRの型にします。そしたら、関数の宣言をして記録します。次にスコープと所有権を持つポインタを管理するものを作って、引数をそのスコープ内の変数として読み取れるようにしていきます。その後、関数の本体のコンパイルを文ごとに連続して呼びます。</p>
<p>ではそれぞれの文をコンパイルするメソッドを見ていきましょう。ここでは主に制御フローと戻り値のIRを生成します。まず式が来た場合は式のIRを作るためのメソッドを呼んで任せます。次に、<code>point ラベル名</code> <code>warpto(行先)</code> <code>warptoif(条件,真のときの行先,偽のときの行先)</code> <code>return 戻り値</code> <code>loopif:ループ名(条件){...}</code>のそれぞれを分岐してIRにしていっています。<code>Return</code>のところに注目するとここで所有権を持っているポインタが所有しているメモリが解放されているかを確認してメモリリークを防いでいます。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compile_stmt(
    &amp;mut self,
    stmt: &amp;Stmt,
    variables: &amp;mut HashMap&lt;String, VariablesPointerAndTypes&lt;'ctx&gt;&gt;,
) {
    match &amp;stmt.expr {
        Expr::IntNumber(_) | Expr::FloatNumber(_) | Expr::Call { .. } | Expr::Ident(_) =&gt; {
            // compile_expr
            self.compile_expr(&amp;stmt.expr, variables);
        }
        Expr::Point(labels) =&gt; {
            let label_name = match &amp;labels[0] {
                Expr::Ident(s) =&gt; Some(s.as_str()),
                _ =&gt; None,
            };
            self.gen_point(label_name.expect("point: missing label literal"));
        }
        Expr::Warp { name, args } =&gt; match name.as_str() {
            "warpto" =&gt; {
                //get label name (point NAME &lt;- this)
                let label_name = match &amp;args[0] {
                    Expr::Ident(s) =&gt; Some(s.as_str()),
                    _ =&gt; None,
                };
                self.gen_warpto(label_name.expect("point: missing label literal"));
            }
            "warptoif" =&gt; {
                // compile condition value
                let cond: BasicValueEnum = self.compile_expr(&amp;args[0], variables).unwrap().0;
                let cond_i1 = match cond {
                    BasicValueEnum::IntValue(v) if v.get_type().get_bit_width() == 1 =&gt; v,
                    _ =&gt; panic!("warptoif condition requires boolean (i1) values"),
                };
                //get label name (point NAME &lt;- this)
                // label_name1 = destination if condition true
                // label_name2 = destination if condition false (optional)
                let label_name1 = match &amp;args[1] {
                    Expr::Ident(s) =&gt; Some(s.as_str()),
                    _ =&gt; None,
                };
                let label_name2 = match &amp;args.get(2) {
                    Some(Expr::Ident(s)) =&gt; Some(s.as_str()),
                    _ =&gt; None,
                };
                self.gen_warptoif(
                    cond_i1,
                    label_name1.expect("point: missing label literal"),
                    label_name2,
                );
            }
            _ =&gt; {
                panic!("warp:not (warpto or warptoif)");
            }
        },
        Expr::Return(vals) =&gt; {
            if vals.len() != 1 {
                panic!("Return must have exactly one value");
            }
            //compile return value
            let ret_val = self
                .compile_expr(vals.into_iter().next().unwrap(), variables)
                .unwrap()
                .0; // unwrap is safe because we already checked vals.len() == 1
            self.builder.build_return(Some(&amp;ret_val)).unwrap();
            // check memory leak
            for i in self.scope_owners.show_current() {
                // if there are Not released memory , print error message
                if let Some(b) = self.current_owners.get(&amp;i.0)
                    &amp;&amp; *b
                {
                    println!(
                        "{}:you need to free or drop pointer {}!",
                        "Error".red().bold(),
                        i.0
                    );
                }
            }
            self.scope_owners.reset_current();
        }
        Expr::Loopif { name, cond, body } =&gt; {
            if cond.len() != 1 {
                panic!("Loopif:{} conditions must have exactly one value", name);
            }

            self.compile_loopif(name, &amp;cond[0], body, variables);
        }
        _ =&gt; unimplemented!(),
    }
}
<span class="boring">}</span></code></pre>
<p>次は式をIRに落とし込むところを見てみましょう。以下のメソッドではリテラル、変数、コンパイラ組み込みの関数の呼び出し、ユーザー定義の関数の呼び出しをIRにしています。すべてのコンパイラ組み込みの関数について書いてあったりするため非常に長くなっていますので全体の流れだけつかめればよいでしょう。</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compile_expr(
    &amp;mut self,
    expr: &amp;Expr,
    variables: &amp;mut HashMap&lt;String, VariablesPointerAndTypes&lt;'ctx&gt;&gt;,
) -&gt; Option&lt;(
    BasicValueEnum&lt;'ctx&gt;,
    Expr,
    Option&lt;VariablesPointerAndTypes&lt;'ctx&gt;&gt;,
)&gt; {
    match expr {
        // Literals
        Expr::IntNumber(n) =&gt; Some((
            self.context.i64_type().const_int(*n as u64, false).into(),
            Expr::Ident("i64".to_string()),
            None,
        )),
        Expr::FloatNumber(n) =&gt; Some((
            self.context.f64_type().const_float(*n).into(),
            Expr::Ident("f64".to_string()),
            None,
        )),
        Expr::IntSNumber(n) =&gt; Some((
            self.context.i32_type().const_int(*n as u64, false).into(),
            Expr::Ident("i32".to_string()),
            None,
        )),
        Expr::FloatSNumber(n) =&gt; Some((
            self.context.f32_type().const_float((*n).into()).into(),
            Expr::Ident("f32".to_string()),
            None,
        )),
        Expr::Bool(b) =&gt; Some((
            self.context.bool_type().const_int(*b as u64, false).into(),
            Expr::Ident("bool".to_string()),
            None,
        )),
        Expr::Char(c) =&gt; Some((
            self.context.i8_type().const_int(*c as u64, false).into(),
            Expr::Ident("char".to_string()),
            None,
        )),
        Expr::String(s) =&gt; {
            //create unique named global string
            let global_str = self
                .builder
                .build_global_string_ptr(s, &amp;format!("str_{}", self.str_counter))
                .unwrap();
            self.str_counter += 1;
            Some((
                global_str.as_pointer_value().into(),
                Expr::TypeApply {
                    base: "ptr".to_string(),
                    args: vec![Expr::Ident("char".to_string())],
                },
                None,
            ))
        }

        // Variables
        Expr::Ident(name) =&gt; {
            //get pointer and variable type
            let alloca = variables
                .get(name)
                .expect(&amp;format!("Undefined variable {}", name)); // safe because variable must exist
            match &amp;alloca.typeexpr {
                //borrow check
                Expr::TypeApply { base, args } if base == "*" =&gt; {
                    // check ownership: if pointer has been moved, reading it is prohibited
                    if !self.current_owners.get(name).expect(&amp;format!(
                        "{} type is *:{:?} but failed to find in ownerships ",
                        name, args[0]
                    )) {
                        println!(
                            "{}:\"{}\" already moved. it is prohibited to read moved pointer",
                            "Error".red().bold(),
                            name
                        )
                    }
                }
                _ =&gt; {}
            }
            Some((
                self.builder
                    .build_load(self.llvm_type_from_expr(&amp;alloca.typeexpr), alloca.ptr, name)
                    .unwrap()
                    .into(),
                alloca.typeexpr.clone(),
                Some(alloca.clone()),
            ))
        }

        Expr::Call { name, args } =&gt; match name.as_str() {
            //return reference
            "ptr" | "&amp;_" =&gt; {
                //if arg is variable , name is variable name
                //else get pointer by from compile_expr
                let name = match &amp;args[0] {
                    Expr::Ident(s) =&gt; s,
                    _ =&gt; {
                        //unwrap because "ptr" or "&amp;_" require an expression with a pointer
                        let (_exp, ty, p) = self.compile_expr(&amp;args[0], variables).unwrap();
                        let ptr = p
                            .expect(&amp;format!(
                                "ptr() and &amp;_ require an expression with a pointer"
                            ))
                            .ptr
                            .as_basic_value_enum();
                        return Some((
                            ptr.clone(),
                            Expr::TypeApply {
                                base: "ptr".to_string(),
                                args: vec![ty],
                            },
                            None,
                        ));
                    }
                };
                let alloca = get_var_alloca(variables, name);
                Some((
                    alloca.as_basic_value_enum(),
                    Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![
                            variables
                                .get(name)
                                .expect(&amp;format!("Undefined variable {}", name))
                                .typeexpr
                                .clone(),
                        ],
                    },
                    None,
                ))
            }
            //dereference
            //val(pointer , option(what type to load it as))
            "val" | "*_" =&gt; {
                //p = (pointer value,type,...)
                // safe: "val" / "*_" always expects an expression that evaluates to a pointer
                let p = self.compile_expr(&amp;args[0], variables).unwrap();
                let ptr = p.0.into_pointer_value();
                let mut load_type = &amp;expr_deref(&amp;p.1); // what type the pointer point
                let ty = args.get(1);
                // Determine the type to load: default is pointer's base type, override if second argument is provided
                load_type = match ty {
                    Some(t) =&gt; t,
                    None =&gt; load_type,
                };
                let loaded = self
                    .builder
                    .build_load(self.llvm_type_from_expr(load_type), ptr, "deref")
                    .unwrap();
                Some((loaded.as_basic_value_enum(), load_type.clone(), None))
            }
            //declaring and initializing variables
            "let" | "#=" =&gt; {
                // args: [var_name, initial_value, type_name]
                let var_name = match &amp;args[0] {
                    Expr::Ident(s) =&gt; s,
                    _ =&gt; panic!("let: first arg must be variable name"),
                };

                let llvm_type: BasicTypeEnum = self.llvm_type_from_expr(&amp;args[2]);

                // If there is an initial value
                let init_val_exist = match &amp;args[1] {
                    Expr::Ident(s) =&gt; {
                        if *s == "_".to_string() {
                            false
                        } else {
                            true
                        }
                    }
                    _ =&gt; true,
                };
                // Check if an initial value is provided; "_" means no initial value
                // If no initial value, zero-initialize (works for numeric types and structs)
                let init_val = if init_val_exist {
                    self.compile_expr(&amp;args[1], variables)
                } else {
                    // For structs, initialize with zeroed
                    Some((
                        llvm_type.const_zero(),
                        Expr::Ident("void".to_string()),
                        None,
                    ))
                };

                // alloca
                let alloca = self
                    .builder
                    .build_alloca(llvm_type, var_name)
                    .expect("fail alloca");
                self.builder
                    .build_store(alloca, init_val.clone().unwrap().0) // safe unwrap: the existence of init_val is already checked
                    .unwrap();
                variables.insert(
                    var_name.clone(),
                    VariablesPointerAndTypes {
                        ptr: alloca,
                        typeexpr: args[2].clone(),
                    },
                );
                // if its type is pointer with Ownership, recoad ownership scope and the entire function ownership
                match &amp;args[2] {
                    Expr::TypeApply { base, args } if base == "*" =&gt; {
                        self.current_owners.insert(var_name.clone(), true);
                        self.scope_owners.set_true(var_name.clone());
                        if !init_val_exist {
                            println!(
                                "{}: {var_name} is Owner (*:{:?}). it must have value",
                                "Error".red().bold(),
                                args
                            )
                        }
                    }
                    Expr::TypeApply { base:_, args:_ } =&gt;{}
                    _ =&gt; if init_val_exist&amp;&amp;!type_match(&amp;args[2], &amp;init_val.clone().unwrap().1) {
                        println!("{}: {var_name} Type miss match : expected {:?} found {:?}","Error".red().bold(),&amp;args[2],&amp;init_val.clone().unwrap().1)
                    },
                }

                Some((init_val.unwrap().0, Expr::Ident("void".to_string()), None))
            }
            // Assignment
            "=" =&gt; match &amp;args[1] {
                // Array assign is special
                Expr::ArrayLiteral(elems) =&gt; Some((
                    self.codegen_array_assign(&amp;args[0], elems, variables)
                        .unwrap(), // safe unwrap: codegen_array_assign returns Some for valid array literals
                    Expr::Ident("void".to_string()),
                    None, // Array assignment does not return a value because the pointer already exists
                )),
                _ =&gt; {
                    let value = self.compile_expr(&amp;args[1], variables).unwrap();
                    let alloca = self.get_pointer_expr(&amp;args[0], variables);
                    // reassign *_(immutable borrow) or val(immutable borrow) is prohibited
                    // Check for immutable borrow: cannot reassign *_(immutable) or val(immutable)
                    if let Expr::Call { name: _name, args } = &amp;args[0]
                        &amp;&amp; let Some(Expr::Ident(s)) = args.get(0)
                        &amp;&amp; let Some(val) = variables.get(s)
                        &amp;&amp; let Expr::TypeApply { base, args: _args } = &amp;val.typeexpr
                        &amp;&amp; base == "&amp;"
                    {
                        println!(
                            "{} :{} :{:?} is immutable borrow! if you want to reassign, use &amp;mut:T",
                            "Error".red().bold(),
                            s,
                            &amp;val.typeexpr
                        );
                    }
                    self.builder.build_store(alloca, value.0).unwrap();
                    Some(value)
                }
            },
            // add,sub,mul,div,rem
            "+" | "-" | "*" | "/" | "%" =&gt; {
                let lhs_val = self.compile_expr(&amp;args[0], variables)?;
                let rhs_val = self.compile_expr(&amp;args[1], variables)?;

                // ===== Type matching: Match the right side to the type of the left side =====
                let rhs_casted = match (lhs_val.0, rhs_val.0) {
                    // ------- When both the left and right are integers -------
                    (BasicValueEnum::IntValue(l), BasicValueEnum::IntValue(r)) =&gt; {
                        let lhs_bits = l.get_type().get_bit_width();
                        let rhs_bits = r.get_type().get_bit_width();

                        let r2 = if lhs_bits &gt; rhs_bits {
                            // i32 → i64
                            self.builder
                                .build_int_s_extend(r, l.get_type(), "int_ext")
                                .unwrap()
                        } else if lhs_bits &lt; rhs_bits {
                            // i64 → i32
                            self.builder
                                .build_int_cast(r, l.get_type(), "int_trunc")
                                .unwrap()
                        } else {
                            r
                        };
                        BasicValueEnum::IntValue(r2)
                    }

                    // ------- When both the left and right are floating point -------
                    (BasicValueEnum::FloatValue(l), BasicValueEnum::FloatValue(r)) =&gt; {
                        let lhs_ty = l.get_type();
                        let rhs_ty = r.get_type();

                        let r2 = if lhs_ty != rhs_ty {
                            let lhs_bits = float_bit_width(lhs_ty);
                            let rhs_bits = float_bit_width(rhs_ty);

                            if lhs_bits &gt; rhs_bits {
                                // f32 → f64
                                self.builder.build_float_ext(r, lhs_ty, "fext").unwrap()
                            } else {
                                // f64 → f32
                                self.builder.build_float_trunc(r, lhs_ty, "ftrunc").unwrap()
                            }
                        } else {
                            r
                        };

                        BasicValueEnum::FloatValue(r2)
                    }

                    // ------- int + float → float (left is float)-------
                    (BasicValueEnum::FloatValue(l), BasicValueEnum::IntValue(r)) =&gt; {
                        let r2 = self
                            .builder
                            .build_signed_int_to_float(r, l.get_type(), "i2f")
                            .unwrap();
                        BasicValueEnum::FloatValue(r2)
                    }

                    // ------- int + float → int (left is int)-------
                    (BasicValueEnum::IntValue(l), BasicValueEnum::FloatValue(r)) =&gt; {
                        let r2 = self
                            .builder
                            .build_float_to_signed_int(r, l.get_type(), "f2i")
                            .unwrap();
                        BasicValueEnum::IntValue(r2)
                    }

                    _ =&gt; panic!("Unsupported combination in binary operation"),
                };

                // ===== Calculation from here =====
                // Perform the arithmetic operation: operands are now type-matched (int or float)
                let result = match (lhs_val.0, rhs_casted) {
                    (BasicValueEnum::IntValue(l), BasicValueEnum::IntValue(r)) =&gt; {
                        let v = match name.as_str() {
                            "+" =&gt; self.builder.build_int_add(l, r, "add").unwrap(),
                            "-" =&gt; self.builder.build_int_sub(l, r, "sub").unwrap(),
                            "*" =&gt; self.builder.build_int_mul(l, r, "mul").unwrap(),
                            "/" =&gt; self.builder.build_int_signed_div(l, r, "div").unwrap(),
                            "%" =&gt; self.builder.build_int_signed_rem(l, r, "rem").unwrap(),
                            _ =&gt; unreachable!(),
                        };
                        v.as_basic_value_enum()
                    }

                    (BasicValueEnum::FloatValue(l), BasicValueEnum::FloatValue(r)) =&gt; {
                        let v = match name.as_str() {
                            "+" =&gt; self.builder.build_float_add(l, r, "fadd").unwrap(),
                            "-" =&gt; self.builder.build_float_sub(l, r, "fsub").unwrap(),
                            "*" =&gt; self.builder.build_float_mul(l, r, "fmul").unwrap(),
                            "/" =&gt; self.builder.build_float_div(l, r, "fdiv").unwrap(),
                            "%" =&gt; self.builder.build_float_rem(l, r, "frem").unwrap(),
                            _ =&gt; unreachable!(),
                        };
                        v.as_basic_value_enum()
                    }

                    _ =&gt; unreachable!(),
                };

                Some((result, lhs_val.1, None))
            }
            // float Special Functions
            "sqrt" | "cos" | "sin" | "pow" | "exp" | "log" =&gt; {
                let compiled_args: Vec&lt;BasicValueEnum&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap().0;
                        val
                    })
                    .collect();
                // check first argument
                let val_l = match compiled_args[0] {
                    BasicValueEnum::FloatValue(v) =&gt; v,
                    // unwrap is safe here because only float arguments are allowed for these intrinsics
                    _ =&gt; panic!("{} require f values", name.as_str()),
                };
                // If the function takes a second argument (e.g., pow), ensure it is a float
                let val_r = if compiled_args.len() &gt; 1 {
                    match compiled_args[1] {
                        BasicValueEnum::FloatValue(v) =&gt; Some(v),
                        // unwrap is safe here because only float arguments are allowed for these intrinsics
                        _ =&gt; panic!("at {} expected float", name.as_str()),
                    }
                } else {
                    None
                };
                match name.as_str() {
                    "sqrt" =&gt; Some((
                        self.call_intrinsic("llvm.sqrt.f64", val_l, val_r),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    "cos" =&gt; Some((
                        self.call_intrinsic("llvm.cos.f64", val_l, val_r),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    "sin" =&gt; Some((
                        self.call_intrinsic("llvm.sin.f64", val_l, val_r),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    "pow" =&gt; Some((
                        self.call_intrinsic("llvm.pow.f64", val_l, val_r),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    "exp" =&gt; Some((
                        self.call_intrinsic("llvm.exp.f64", val_l, val_r),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    "log" =&gt; Some((
                        self.call_intrinsic("llvm.log.f64", val_l, val_r),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    _ =&gt; None,
                }
            }
            // Compile binary comparison operations. Returns boolean i1 value.
            "==" | "!=" | "&lt;=" | "&gt;=" | "&lt;" | "&gt;" =&gt; {
                let compiled_args: Vec&lt;BasicValueEnum&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap().0;
                        val
                    })
                    .collect();
                let v = match name.as_str() {
                    "==" =&gt; Some(
                        self.build_eq(compiled_args[0], compiled_args[1])
                            .as_basic_value_enum(),
                    ),
                    "!=" =&gt; Some(
                        self.build_neq(compiled_args[0], compiled_args[1])
                            .as_basic_value_enum(),
                    ),
                    "&lt;" =&gt; Some(
                        self.build_lt(compiled_args[0], compiled_args[1])
                            .as_basic_value_enum(),
                    ),
                    "&gt;" =&gt; Some(
                        self.build_gt(compiled_args[0], compiled_args[1])
                            .as_basic_value_enum(),
                    ),
                    "&lt;=" =&gt; Some(
                        self.build_le(compiled_args[0], compiled_args[1])
                            .as_basic_value_enum(),
                    ),
                    "&gt;=" =&gt; Some(
                        self.build_ge(compiled_args[0], compiled_args[1])
                            .as_basic_value_enum(),
                    ),
                    _ =&gt; None,
                };
                Some((
                    v.expect("Unsupported comparison operator"),
                    Expr::Ident("bool".to_string()),
                    None,
                ))
            }
            // Bitwise Operations
            //and,or,xor,left shift,right shift(sign extend is true),right shift(sign extend is false)
            "&amp;" | "|" | "^" | "&lt;&lt;" | "&gt;&gt;" | "l&gt;&gt;" =&gt; {
                let compiled_args: Vec&lt;(
                    BasicValueEnum,
                    Expr,
                    Option&lt;VariablesPointerAndTypes&gt;,
                )&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap();
                        val
                    })
                    .collect();
                let val_l = match compiled_args[0].0 {
                    BasicValueEnum::IntValue(v) =&gt; v,
                    _ =&gt; panic!("{} require i values", name.as_str()),
                };
                let val_r = match compiled_args[1].0 {
                    BasicValueEnum::IntValue(v) =&gt; v,
                    _ =&gt; panic!("{} require i values", name.as_str()),
                };
                // compiled_args[0].clone().1 is type of first argument
                // return type is type of  first argument
                match name.as_str() {
                    "&amp;" =&gt; Some((
                        self.builder
                            .build_and(val_l, val_r, "and_tmp")
                            .unwrap()
                            .as_basic_value_enum(),
                        compiled_args[0].clone().1,
                        None,
                    )),
                    "|" =&gt; Some((
                        self.builder
                            .build_or(val_l, val_r, "or_tmp")
                            .unwrap()
                            .as_basic_value_enum(),
                        compiled_args[0].clone().1,
                        None,
                    )),
                    "^" =&gt; Some((
                        self.builder
                            .build_xor(val_l, val_r, "xor_tmp")
                            .unwrap()
                            .as_basic_value_enum(),
                        compiled_args[0].clone().1,
                        None,
                    )),
                    "&lt;&lt;" =&gt; Some((
                        self.builder
                            .build_left_shift(val_l, val_r, "&lt;&lt;_tmp")
                            .unwrap()
                            .as_basic_value_enum(),
                        compiled_args[0].clone().1,
                        None,
                    )),
                    "&gt;&gt;" =&gt; Some((
                        self.builder
                            .build_right_shift(val_l, val_r, true, "&gt;&gt;_tmp")
                            .unwrap()
                            .as_basic_value_enum(),
                        compiled_args[0].clone().1,
                        None,
                    )),
                    "l&gt;&gt;" =&gt; Some((
                        self.builder
                            .build_right_shift(val_l, val_r, false, "l&gt;&gt;_tmp")
                            .unwrap()
                            .as_basic_value_enum(),
                        compiled_args[0].clone().1,
                        None,
                    )),
                    _ =&gt; panic!("Unsupported bitwise operator: {}", name),
                }
            }
            // Bool Operations
            // &amp;&amp; = and, || = or
            "&amp;&amp;" | "||" | "and" | "or" =&gt; {
                let compiled_args: Vec&lt;(
                    BasicValueEnum,
                    Expr,
                    Option&lt;VariablesPointerAndTypes&gt;,
                )&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap();
                        val
                    })
                    .collect();
                let lhs_i1 = match compiled_args[0].0 {
                    BasicValueEnum::IntValue(v) if v.get_type().get_bit_width() == 1 =&gt; v,
                    _ =&gt; panic!("{} require bool values", name.as_str()),
                };
                let rhs_i1 = match compiled_args[1].0 {
                    BasicValueEnum::IntValue(v) if v.get_type().get_bit_width() == 1 =&gt; v,
                    _ =&gt; panic!("{} require bool values", name.as_str()),
                };
                let v = match name.as_str() {
                    "&amp;&amp;" | "and" =&gt; Some(
                        self.builder
                            .build_and(lhs_i1, rhs_i1, "and")
                            .unwrap()
                            .as_basic_value_enum(),
                    ),
                    "||" | "or" =&gt; Some(
                        self.builder
                            .build_or(lhs_i1, rhs_i1, "or")
                            .unwrap()
                            .as_basic_value_enum(),
                    ),
                    _ =&gt; None,
                };
                Some((v.unwrap(), Expr::Ident("bool".to_string()), None))
            }
            // Bit Reverse
            "!" | "not" =&gt; {
                let compiled_args: Vec&lt;(BasicValueEnum, Expr, Option&lt;_&gt;)&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap();
                        val
                    })
                    .collect();
                let val_i1 = match compiled_args[0].0 {
                    BasicValueEnum::IntValue(v) =&gt; v,
                    _ =&gt; panic!("{} require int or bool values", name.as_str()),
                };
                Some((
                    self.builder
                        .build_not(val_i1, "not_tmp")
                        .unwrap()
                        .as_basic_value_enum(),
                    compiled_args[0].clone().1,
                    None,
                ))
            }
            // Cast to numeric types
            // char, i32/i64, f32/f64 -&gt; cast to i64 or f64
            // String -&gt; parsed to i64 or f64
            "as_i64" | "as_f64" =&gt; {
                let compiled_args: Vec&lt;(BasicValueEnum, Expr, Option&lt;_&gt;)&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self
                            .compile_expr(arg, variables)
                            .expect("argument must have value");
                        val
                    })
                    .collect();

                match name.as_str() {
                    "as_i64" =&gt; Some((
                        self.build_cast_to_i64(compiled_args[0].0)
                            .as_basic_value_enum(),
                        Expr::Ident("i64".to_string()),
                        None,
                    )),
                    "as_f64" =&gt; Some((
                        self.build_cast_to_f64(compiled_args[0].0)
                            .as_basic_value_enum(),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    _ =&gt; None,
                }
            }
            // Deprecated names for backward compatibility
            // They behave the same as "as_i64" | "as_f64"
            // Kept to allow older code to continue working
            "parse_i64" | "parse_f64" =&gt; {
                let compiled_args: Vec&lt;(BasicValueEnum, Expr, Option&lt;_&gt;)&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap();
                        val
                    })
                    .collect();
                match name.as_str() {
                    "parse_i64" =&gt; Some((
                        self.build_cast_to_i64(compiled_args[0].0)
                            .as_basic_value_enum(),
                        Expr::Ident("i64".to_string()),
                        None,
                    )),
                    "parse_f64" =&gt; Some((
                        self.build_cast_to_f64(compiled_args[0].0)
                            .as_basic_value_enum(),
                        Expr::Ident("f64".to_string()),
                        None,
                    )),
                    _ =&gt; None,
                }
            }
            // Pure if expression: if(cond, then_val, else_val)
            // Both 'then_val' and 'else_val' are always evaluated.
            // Avoid side effects in either branch.
            "if" =&gt; {
                let compiled_args: Vec&lt;(BasicValueEnum, Expr, Option&lt;_&gt;)&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap();
                        val
                    })
                    .collect();
                Some((
                    self.build_if_expr(
                        compiled_args[0].0,
                        compiled_args[1].0,
                        compiled_args[2].0,
                        "if",
                    ),
                    compiled_args[1].clone().1,
                    None,
                ))
            }
            // Print with newline
            "println" =&gt; {
                let s_val = self.compile_expr(&amp;args[0], variables).unwrap();
                let str_ptr = match s_val.0 {
                    BasicValueEnum::PointerValue(p) =&gt; p,
                    _ =&gt; panic!("println expects string pointer"),
                };
                self.build_println_from_ptr(str_ptr);
                None
            }
            // Print without newline
            "print" =&gt; {
                let s_val = self.compile_expr(&amp;args[0], variables).unwrap();
                let str_ptr = match s_val.0 {
                    BasicValueEnum::PointerValue(p) =&gt; p,
                    _ =&gt; panic!("print expects string pointer"),
                };
                self.build_print_from_ptr(str_ptr);
                None
            }
            // Wrapper of sprintf
            "format" =&gt; {
                // string pointer
                let fmt_val = self.compile_expr(&amp;args[0], variables).unwrap();

                let fmt_ptr = match fmt_val.0 {
                    BasicValueEnum::PointerValue(p) =&gt; p,
                    _ =&gt; panic!("format expects string pointer"),
                };
                // Remaining arguments: values to format
                let arg_vals: Vec&lt;_&gt; = args[1..]
                    .iter()
                    .map(|a| self.compile_expr(a, variables).unwrap().0)
                    .collect();
                // Returns a string pointer containing the formatted string
                let res_ptr = self.build_format_from_ptr(fmt_ptr, &amp;arg_vals);
                Some((
                    res_ptr.into(),
                    Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![Expr::Ident("char".to_string())],
                    },
                    None,
                ))
            }
            // Pointer addition in 1-byte units (like void* + n)
            "ptr_add_byte" =&gt; {
                // args: [ptr, idx] or [idx, ptr]
                let val_l = self.compile_expr(&amp;args[0], variables).unwrap();
                let val_r = self.compile_expr(&amp;args[1], variables).unwrap();

                let (ptr_val, idx_int) = match (val_l.0, val_r.0) {
                    (BasicValueEnum::PointerValue(p), BasicValueEnum::IntValue(i)) =&gt; {
                        (p, self.int_to_i64(i))
                    }
                    (BasicValueEnum::IntValue(i), BasicValueEnum::PointerValue(p)) =&gt; {
                        (p, self.int_to_i64(i))
                    }
                    _ =&gt; panic!("ptr_add expects (ptr, int) or (int, ptr)"),
                };
                // GEP using i8 as element type =&gt; 1 byte unit
                let gep = unsafe {
                    self.builder
                        .build_gep(
                            self.llvm_type_from_expr(&amp;Expr::Ident("T".to_string())), // 1byte
                            ptr_val,
                            &amp;[idx_int],
                            "ptr_add_byte",
                        )
                        .unwrap()
                };
                // return as ptr:T (like void*)
                // borrow checker doesn't check "ptr" type pointer
                Some((
                    gep.as_basic_value_enum(),
                    Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![Expr::Ident("T".to_string())],
                    },
                    None,
                ))
            }
            // Pointer addition in units of the pointed-to type
            // Returns the same pointer type as the left operand
            "ptr_add" =&gt; {
                // args: [ptr, idx] or [idx, ptr]
                let val_l = self.compile_expr(&amp;args[0], variables).unwrap();
                let val_r = self.compile_expr(&amp;args[1], variables).unwrap();

                let (ptr_val, idx_int) = match (val_l.0, val_r.0) {
                    (BasicValueEnum::PointerValue(p), BasicValueEnum::IntValue(i)) =&gt; {
                        (p, self.int_to_i64(i))
                    }
                    (BasicValueEnum::IntValue(i), BasicValueEnum::PointerValue(p)) =&gt; {
                        (p, self.int_to_i64(i))
                    }
                    _ =&gt; panic!("ptr_add expects (ptr, int) or (int, ptr)"),
                };
                // GEP using the type pointed by left operand =&gt; adds in units of that type
                let gep = unsafe {
                    self.builder
                        .build_gep(
                            self.llvm_type_from_expr(&amp;expr_deref(&amp;val_l.1)),
                            ptr_val,
                            &amp;[idx_int],
                            "ptr_add",
                        )
                        .unwrap()
                };

                Some((gep.as_basic_value_enum(), val_l.1, None))
            }
            // for backward compatibility
            // non-multidimensional version of []
            "index" =&gt; {
                // args: [ptr, idx] or [idx, ptr] -&gt; load *(ptr + idx)
                let a = self.compile_expr(&amp;args[0], variables).unwrap();
                let b = self.compile_expr(&amp;args[1], variables).unwrap();
                let (ptr_val, idx_int) = match (a.0, b.0) {
                    (BasicValueEnum::PointerValue(p), BasicValueEnum::IntValue(i)) =&gt; {
                        (p, self.int_to_i64(i))
                    }
                    (BasicValueEnum::IntValue(i), BasicValueEnum::PointerValue(p)) =&gt; {
                        (p, self.int_to_i64(i))
                    }
                    _ =&gt; panic!("index expects (ptr,int) or (int,ptr)"),
                };

                let gep = unsafe {
                    self.builder
                        .build_gep(
                            self.llvm_type_from_expr(&amp;expr_deref(&amp;a.1)),
                            ptr_val,
                            &amp;[idx_int],
                            "idx_ptr",
                        )
                        .unwrap()
                };
                let loaded = self
                    .builder
                    .build_load(self.llvm_type_from_expr(&amp;expr_deref(&amp;a.1)), gep, "idx_load")
                    .unwrap();
                Some((
                    loaded.as_basic_value_enum(),
                    expr_deref(&amp;a.1),
                    Some(VariablesPointerAndTypes {
                        ptr: gep,
                        typeexpr: expr_deref(&amp;a.1),
                    }),
                ))
            }
            // index access
            // [](arr , e1 ,e2 ,...) = arr[e1][e2]...
            "[]" =&gt; {
                let depth = args.len(); // number of indices + 1 (for array pointer)
                let arr_pointer = self.compile_expr(&amp;args[0], variables).unwrap();
                let ptr_val = match arr_pointer.0 {
                    BasicValueEnum::PointerValue(p) =&gt; p,
                    _ =&gt; panic!("[] expect ptr,i64,i64,... found {:?}", arr_pointer.1),
                };

                let mut last_ptr = ptr_val;
                let mut typeexp = arr_pointer.1;
                for i in 1..depth {
                    let (val, ty, _p) = self.compile_expr(&amp;args[i], variables).unwrap();
                    let idx_int = match val {
                        BasicValueEnum::IntValue(i_val) =&gt; self.int_to_i64(i_val),
                        _ =&gt; panic!("[] expect ptr,i64,i64,... found {:?}", ty),
                    };
                    let gep = unsafe {
                        self.builder
                            .build_gep(
                                self.llvm_type_from_expr(&amp;expr_deref(&amp;typeexp)),
                                last_ptr,
                                &amp;[idx_int],
                                "idx_ptr",
                            )
                            .unwrap()
                    };
                    if i == depth - 1 {
                        last_ptr = gep;
                        break;
                    }
                    last_ptr = self
                        .builder
                        .build_load(
                            self.llvm_type_from_expr(&amp;expr_deref(&amp;typeexp)),
                            gep,
                            "idx_load",
                        )
                        .unwrap()
                        .into_pointer_value();
                    typeexp = expr_deref(&amp;typeexp);
                }
                typeexp = expr_deref(&amp;typeexp);
                let loaded = self
                    .builder
                    .build_load(self.llvm_type_from_expr(&amp;typeexp), last_ptr, "idx[]_load")
                    .unwrap();
                Some((
                    loaded.as_basic_value_enum(),
                    typeexp.clone(),
                    Some(VariablesPointerAndTypes {
                        ptr: last_ptr,
                        typeexpr: typeexp.clone(),
                    }),
                ))
            }
            // Allocate memory on the stack
            "alloc_array" | "alloc" =&gt; {
                // args: [type_name, length_expr]

                // type of elements
                let elem_ty = self.llvm_type_from_expr(&amp;args[0]);

                // capacity = IntValue
                let len_val = self.compile_expr(&amp;args[1], variables).unwrap();
                let len_val = match len_val.0 {
                    BasicValueEnum::IntValue(i) =&gt; i,
                    _ =&gt; panic!("alloc_array: length must be integer"),
                };

                // elem_ty must be IntType , FloatType or PointerType = bool,char,i32,i64,T,f64,f32,ptr,&amp;,&amp;mut,*

                let array_ptr = self
                    .builder
                    .build_array_alloca(elem_ty, len_val, "array")
                    .unwrap();

                // let array_ptr = match elem_ty {
                //     BasicTypeEnum::IntType(t) =&gt; self
                //         .builder
                //         .build_array_alloca(t, len_val, "array")
                //         .unwrap(),
                //     BasicTypeEnum::FloatType(t) =&gt; self
                //         .builder
                //         .build_array_alloca(t, len_val, "array")
                //         .unwrap(),
                //     BasicTypeEnum::PointerType(t) =&gt; self
                //         .builder
                //         .build_array_alloca(t, len_val, "array")
                //         .unwrap(),
                //     _ =&gt; panic!("alloc_array: unsupported type"),
                // };
                // Return as ptr:elem_ty
                Some((
                    array_ptr.as_basic_value_enum(),
                    Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![args[0].clone()],
                    },
                    None,
                ))
            }
            "free" =&gt; {
                self.compile_free(&amp;args[0], variables);
                None
            }
            // Transfer ownership of *:T variable
            "pmove" =&gt; {
                let (val, ty, ptr) = self.compile_expr(&amp;args[0], variables).unwrap();
                match &amp;ty {
                    // Expect variable identifier
                    Expr::TypeApply { base, args: _ } if base == "*" =&gt; {
                        if let Expr::Ident(var_name) = &amp;args[0] {
                            // Check if variable has already been moved
                            if let Some(owned) = self.current_owners.get_mut(var_name) {
                                if !*owned {
                                    println!(
                                        "{} : at pmove \"{}\" already moved",
                                        "Error".red().bold(),
                                        var_name
                                    );
                                }
                                *owned = false;
                            }
                            if let Some(owned) = self.scope_owners.owners[self.scope_owners.pos]
                                .get_mut(var_name)
                            {
                                *owned = false;
                            }
                        }
                    }
                    Expr::TypeApply { base, args: _args } if base == "&amp;" || base == "&amp;mut" =&gt; {
                        println!(
                            "{} pmove expect *:T variables found {:?}",
                            "Error".red().bold(),
                            &amp;ty
                        );
                    }
                    _ =&gt; {
                        println!(
                            "{} pmove expect *:T variables found {:?}",
                            "Error".red().bold(),
                            &amp;args[0]
                        );
                    }
                }
                Some((val, ty, ptr))
            }
            // immutable borrow
            "p&amp;" =&gt; {
                let (val, ty, ptr) = self.compile_expr(&amp;args[0], variables).unwrap();
                Some((
                    val,
                    Expr::TypeApply {
                        base: "&amp;".to_string(),
                        args: vec![expr_deref(&amp;ty)],
                    },
                    ptr,
                ))
            }
            // mutable borrow
            "p&amp;mut" =&gt; {
                let (val, ty, ptr) = self.compile_expr(&amp;args[0], variables).unwrap();
                match &amp;ty {
                    Expr::TypeApply { base, args: _args } if base == "&amp;" =&gt; {
                        println!(
                            "{}: p&amp;mut expect &amp;mut:T or *:T found {:?} {:?}",
                            "Error".red().bold(),
                            ty,
                            &amp;args[0]
                        )
                    }
                    _ =&gt; {}
                }
                Some((
                    val,
                    Expr::TypeApply {
                        base: "&amp;mut".to_string(),
                        args: vec![expr_deref(&amp;ty)],
                    },
                    ptr,
                ))
            }
            // malloc(size,elements_type)
            // malloc require pointed type for type safety
            // this is safety wrapper of C malloc
            "malloc" =&gt; {
                let compiled_size = self.compile_expr(&amp;args[0], variables).unwrap();
                let size = match compiled_size.0 {
                    BasicValueEnum::IntValue(i) =&gt; Some(i),
                    _ =&gt; panic!("malloc expects integer size"),
                };
                let ele_type = self.llvm_type_from_expr(&amp;args[1]);
                // return ptr:elements_type
                Some((
                    self.compile_malloc(size.unwrap(), ele_type)
                        .as_basic_value_enum(),
                    Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![args[1].clone()],
                    },
                    None,
                ))
            }
            // realloc(ptr ,size,elements_type)
            // realloc require pointed type for type safety
            // this is safety wrapper of C realloc
            "realloc" =&gt; {
                let ptr = match self.compile_expr(&amp;args[0], variables).unwrap().0 {
                    BasicValueEnum::PointerValue(p) =&gt; p,
                    _ =&gt; panic!("realloc expects (ptr,size,type)"),
                };
                let compiled_size = self.compile_expr(&amp;args[1], variables).unwrap();
                let size = match compiled_size.0 {
                    BasicValueEnum::IntValue(i) =&gt; Some(i),
                    _ =&gt; panic!("realloc expects (ptr,size,type)"),
                };
                let ele_type = self.llvm_type_from_expr(&amp;args[2]);
                // return ptr:elements_type
                Some((
                    self.compile_realloc(ptr, size.unwrap(), ele_type)
                        .as_basic_value_enum(),
                    Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![args[2].clone()],
                    },
                    None,
                ))
            }
            // memcpy(dest,src,size)
            "memcpy" =&gt; {
                let dest_ptr = self.compile_expr(&amp;args[0], variables).unwrap();
                let src_ptr = self.compile_expr(&amp;args[1], variables).unwrap();
                let size = self.compile_expr(&amp;args[2], variables).unwrap();
                let (dest_i8, src_i8, size_int) = match (dest_ptr.0, src_ptr.0, size.0) {
                    (
                        BasicValueEnum::PointerValue(d),
                        BasicValueEnum::PointerValue(s),
                        BasicValueEnum::IntValue(i),
                    ) =&gt; (
                        self.builder
                            .build_pointer_cast(
                                d,
                                self.context.ptr_type(AddressSpace::default()),
                                "dest8",
                            )
                            .unwrap(),
                        self.builder
                            .build_pointer_cast(
                                s,
                                self.context.ptr_type(AddressSpace::default()),
                                "dest8",
                            )
                            .unwrap(),
                        i,
                    ),
                    _ =&gt; panic!(
                        "memcpy expects (ptr,ptr,int) found {:?},{:?},{:?}",
                        dest_ptr.1, src_ptr.1, size.1
                    ),
                };
                self.builder
                    .build_memcpy(dest_i8, 1, src_i8, 1, size_int)
                    .unwrap();

                None
            }
            // memmove(dest,src,size)
            "memmove" =&gt; {
                let dest_ptr = self.compile_expr(&amp;args[0], variables).unwrap();
                let src_ptr = self.compile_expr(&amp;args[1], variables).unwrap();
                let size = self.compile_expr(&amp;args[2], variables).unwrap();
                let (dest_i8, src_i8, size_int) = match (dest_ptr.0, src_ptr.0, size.0) {
                    (
                        BasicValueEnum::PointerValue(d),
                        BasicValueEnum::PointerValue(s),
                        BasicValueEnum::IntValue(i),
                    ) =&gt; (
                        self.builder
                            .build_pointer_cast(
                                d,
                                self.context.ptr_type(AddressSpace::default()),
                                "dest8",
                            )
                            .unwrap(),
                        self.builder
                            .build_pointer_cast(
                                s,
                                self.context.ptr_type(AddressSpace::default()),
                                "dest8",
                            )
                            .unwrap(),
                        i,
                    ),
                    _ =&gt; panic!(
                        "memmove expects (ptr,ptr,int)found {:?},{:?},{:?}",
                        dest_ptr.1, src_ptr.1, size.1
                    ),
                };
                self.builder
                    .build_memmove(dest_i8, 1, src_i8, 1, size_int)
                    .unwrap();

                None
            }
            // memmove(dest,value,size)
            "memset" =&gt; {
                let dest_ptr = self.compile_expr(&amp;args[0], variables).unwrap();
                let src_val = self.compile_expr(&amp;args[1], variables).unwrap();
                let size = self.compile_expr(&amp;args[2], variables).unwrap();
                let (dest_i8, value, size_int) = match (dest_ptr.0, src_val.0, size.0) {
                    (
                        BasicValueEnum::PointerValue(d),
                        BasicValueEnum::IntValue(v),
                        BasicValueEnum::IntValue(s),
                    ) =&gt; (
                        self.builder
                            .build_pointer_cast(
                                d,
                                self.context.ptr_type(AddressSpace::default()),
                                "dest8",
                            )
                            .unwrap(),
                        v,
                        s,
                    ),
                    _ =&gt; panic!("memset expects (ptr,val,int)"),
                };
                let value_i8 = self
                    .builder
                    .build_int_truncate(value, self.context.i8_type(), "val8")
                    .unwrap();
                self.builder
                    .build_memset(dest_i8, 1, value_i8, size_int)
                    .unwrap();

                None
            }
            //return type size in byte as i64
            "sizeof" =&gt; Some((
                self.compile_sizeof(&amp;args[0]),
                Expr::Ident("i64".to_string()),
                None,
            )),
            // === struct member access ===
            // "_&gt;": struct pointer -&gt; member value (dereference pointer, then load member)
            // ".": struct value -&gt; member value (use alloca of struct value, then load member)
            // "-&gt;": struct pointer -&gt; member pointer (get pointer to member, do not load)
            // struct member access
            // struct pointer -&gt; member value
            "_&gt;" =&gt; {
                let value_struct = self.compile_expr(&amp;args[0], variables).unwrap();
                let (memberptr, membertype) =
                    self.compile_member_access(value_struct.0, &amp;args[1], &amp;value_struct.1);
                let member_value = self
                    .builder
                    .build_load(
                        self.llvm_type_from_expr(&amp;expr_deref(&amp;membertype)),
                        memberptr,
                        "getmembervalue",
                    )
                    .unwrap();
                Some((
                    member_value.into(),
                    expr_deref(&amp;membertype),
                    Some(VariablesPointerAndTypes {
                        ptr: memberptr,
                        typeexpr: expr_deref(&amp;membertype),
                    }),
                ))
            }
            // struct member access
            // struct value -&gt; member value
            "." =&gt; {
                let value_struct = self.compile_expr(&amp;args[0], variables).unwrap();
                let alloca = value_struct.2.unwrap().ptr;
                let (memberptr, membertype) = self.compile_member_access(
                    alloca.as_basic_value_enum(),
                    &amp;args[1],
                    &amp;Expr::TypeApply {
                        base: "ptr".to_string(),
                        args: vec![value_struct.1],
                    },
                );
                let member_value = self
                    .builder
                    .build_load(
                        self.llvm_type_from_expr(&amp;expr_deref(&amp;membertype)),
                        memberptr,
                        "getmembervalue",
                    )
                    .unwrap();
                Some((
                    member_value.into(),
                    expr_deref(&amp;membertype),
                    Some(VariablesPointerAndTypes {
                        ptr: memberptr,
                        typeexpr: expr_deref(&amp;membertype),
                    }),
                ))
            }
            // struct member access
            // struct pointer -&gt; member pointer
            "-&gt;" =&gt; {
                let value_struct = self.compile_expr(&amp;args[0], variables).unwrap();
                let (memberptr, membertype) =
                    self.compile_member_access(value_struct.0, &amp;args[1], &amp;value_struct.1);
                Some((memberptr.as_basic_value_enum().into(), membertype, None))
            }
            // wrapper of C scanf
            "scanf" =&gt; {
                let fmt_val = self.compile_expr(&amp;args[0], variables).unwrap();
                // Remaining arguments: values to format
                let fmt_ptr = match fmt_val.0 {
                    BasicValueEnum::PointerValue(p) =&gt; p,
                    _ =&gt; panic!("scanf expects string pointer"),
                };
                let arg_vals: Vec&lt;_&gt; = args[1..]
                    .iter()
                    .map(|a| self.compile_expr(a, variables).unwrap().0)
                    .collect();
                self.build_scan_from_ptr(fmt_ptr, &amp;arg_vals);
                None
            }
            // cast to generic pointer
            "to_anyptr" =&gt; {
                // to_anyptr(ptr)
                let ptr = self.compile_expr(&amp;args[0], variables);
                match ptr.unwrap().0 {
                    BasicValueEnum::PointerValue(p) =&gt; Some((
                        self.compile_to_anyptr(p, variables).as_basic_value_enum(),
                        Expr::TypeApply {
                            base: "ptr".to_string(),
                            args: vec![Expr::Ident("T".to_string())],
                        },
                        None,
                    )),
                    _ =&gt; None,
                }
            }
            // cast from generic pointer
            "from_anyptr" =&gt; {
                // from_anyptr(ptr,pointed type)
                let ptr = self.compile_expr(&amp;args[0], variables);
                let target_type = self.llvm_type_from_expr(&amp;args[1]);
                match (ptr.unwrap().0, target_type) {
                    (BasicValueEnum::PointerValue(p), BasicTypeEnum::PointerType(target)) =&gt; {
                        Some((
                            self.compile_from_anyptr(p, target).as_basic_value_enum(),
                            Expr::TypeApply {
                                base: "ptr".to_string(),
                                args: vec![args[1].clone()],
                            },
                            None,
                        ))
                    }
                    _ =&gt; None,
                }
            }
            // Call other functions
            name =&gt; {
                // Lookup LLVM function by name.
                let func = self
                    .module
                    .get_function(&amp;name)
                    .expect(&amp;format!("Function {} not found", name));
                // Compile each argument and convert to BasicMetadataValueEnum,
                // which is required by build_call.
                let compiled_args: Vec&lt;BasicMetadataValueEnum&gt; = args
                    .into_iter()
                    .map(|arg| {
                        let val = self.compile_expr(arg, variables).unwrap();
                        BasicMetadataValueEnum::from(val.0)
                    })
                    .collect();
                // Emit LLVM call instruction
                let call_site = self
                    .builder
                    .build_call(func, &amp;compiled_args, "calltmp")
                    .unwrap();
                // If the function has a return value, extract it.
                if func.get_type().get_return_type().is_some() {
                    Some((
                        call_site.try_as_basic_value().basic().unwrap(),
                        // return type is stored in function_types map (AST-level type)
                        self.function_types
                            .get(name)
                            .expect(&amp;format!("not defined function {}", name))
                            .clone(),
                        None,
                    ))
                } else {
                    None // return is void
                }
            }
        },

        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre>
<p>お疲れ様です。この本でのWapLコンパイラの作り方の説明は一旦ここまでにしておきます。ソースコードは<a href="https://github.com/kazanefu/WapL_Compiler">https://github.com/kazanefu/WapL_Compiler</a>で公開されているので興味があれば見てみてください。もし問題点を見つけたり改善をしてくれたら遠慮なく報告していただけるとありがたいです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="huroku.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="howtoinstallclang.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="huroku.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="howtoinstallclang.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/highlight-837a6fa5.min.js"></script>
        <script src="theme/wapl-6b44a6eb.js"></script>
        <script src="theme/wapl-rainbow-f254588b.js"></script>



    </div>
    </body>
</html>
